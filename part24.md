##  第四章 抽象和接口
###  4.1 抽象类
#### 4.1.1 抽象类
前面使用 Shape 类可以话出很多形状。父类源代码如下：  
![abstract](image/part2/abstract.png)  
在 public 和 class 中间多了一个 abstract。类中唯一一个函数在 public 和 draw 中间也有 abstract。这个单词的意思是 **抽象**。为什么要这样？  

##### Shape 是什么形状？
* Shape 类的 draw() 函数应该如何写？
![abstract2](image/part2/abstract2.png)  
我们现在 Shape 类家族如上图所示，从 Shape 类派生出了 Rectangle Ellipse Square Circle 等各种各样的形状。在 Shape 里面我们定义了 draw() 的函数，这个函数定义出来以后，所有的 Shape 子类都有一个 draw() 的函数。假如我们现在来写 Circle，这个 Circle 的 draw() 怎么做？很简单，画个圆；如果做个 Square, Square 的 draw()怎么做呢？很简单，画个矩形。但是如果我和你说现在有个 Shape，让你画个形状，你画什么？也就是说像 Shape 这个类在程序中的作用是什么？它提供了 Rectangle Square Ellipse Circle 等公共的概念，公共的父类。在这个公共概念当中，它提出了所有的 Shapes 不管哪种形状，都应该会 draw()，这是讲多态时提的概念。有公共的父类提出 draw() 这件事情，以至于所有的子类都能够 draw()，这就是这个公共父类存在的意义。如果没有这个 Shape，那么 Circle 和 Rectangle 就没有关系了。因为有 Shape，可以认为 Circle 和 Rectangle 都是 Shape，所以 Shape 类的意义就在这。我们没有想过要产生 Shape 类的一个对象，如果有一个 Shape 类的对象，你就没有办法说我到底要你怎么 draw()。因为它没有任何存在的意义，他只是表达一种概念。在这种情况下，我们最合适的方式是让这个类成为一个 abstract 类，即抽象类。而这个抽象类中的那个 draw() 方法，它在这个类中没有存在的意义，他的意义就是告诉别人说所有的 Shape 类的子类都有一个 draw() 函数。所以这个函数本身也应该是一个抽象的，abstract。  

从语法上来说，由于这个 draw() 是抽象的，所以 draw()函数没有表示函数体的大括号，加上会报错。如果有一个函数是抽象的，那么这个类就是抽象的，要加关键字 abstract。因为抽象类还有另外一层意思，就是抽象类不能产生对象。假如说某个类中有一个抽象函数，但是这个类不是抽象的。类不是抽象的意味着这个类可以产生对象了，如果我们制造了这个类的对象 s，那么 s.draw() 改怎么做呢？这个 draw() 函数没有定义，没有 body，我们只是声明这里有个 draw()，没有给出函数体呀，s.draw() 依然无法执行。所以只要一个类中有一个函数时抽象的，那么这个类就是抽象的。  

##### 抽象函数/抽象类
* 抽象函数 -- 表达概念而无法实现具体代码的函数
* 抽象类 -- 表达概念而无法构造出实体的类

从定义上来说，抽象函数就是表达概念而无法实现具体代码的函数，比如说，Shape 类中的那个 draw()；抽象类就是表达概念而无法构造出实体的类，一旦你这个类中有一个抽象函数了，这个类就是抽象类。

* 带有 abstract 修饰符的函数
* 有抽象函数的类一定是抽象类
* 抽象类不能制造对象
* 但是可以定义变量
    + 任何继承了抽象类的非抽象类的对象可以赋给这个变量

在 Java 使用修饰符即关键字 abstract 单词的本意就是抽象，用这个单词去修饰函数、修饰类去表明它是抽象的。抽象类不能制造对象，但是可以使用抽象类定义变量，当然将来赋给这个类定义的变量的对象一定是这个类的非抽象的子类，才能赋给这个类的抽象变量。这个抽象类的变量的意思就是任何，比如 Shape 类的变量 s，那指的就是任何 Shape 类的子类的对象都可以由这个 s 来管理，指的是管理子类的对象的变量。  

##### 实现抽象函数
* 继承自抽象类的子类必须覆盖父类中的抽象函数
* 否则自己成为抽象类

当我们有一个子类，这个子类继承了抽象类以后呢，那个抽象类里面的所有的抽象函数，都必须要被这个子类实现，即被它覆盖，这种覆盖我们叫做**实现**。否则这个类自己就成为抽象类。如果一个类继承了一个抽象类，但是没有实现所有的抽象方法，那个这个类就是抽象类。  

##### 两种抽象
* 与具体相对
  + 表示一种概念而非实体
* 与细节相对
  + 表示在一定程度上忽略细节而着眼大局

在计算机中，抽象有两种不同的意义，只是很多人没有意识到这一点。我们会在两种不同的语境下用抽象这个词，它们的含义有相似的地方，但也有细微的不同。两种抽象，一种抽象和具体相对，比如 Shape 类的抽象，就和具体相对，因为 Shape 表达的是概念而不是具体的东西，Circle 才有可能是具体的东西，Line 才有可能是具体的东西，所以和具体相对的是一种抽象。但其实还有另外一种抽象，是和细节相对，比方说当我看到一辆汽车的时候，普通人会说是蓝色的轿车，他不会说这个车的发动机是4缸的，是什么样的变速箱，正常人不会想这些事情，人的思维都会在一定程度上掩盖细节，不会看到一定层次上细节下面的东西，这是另外一种抽象，所以在计算机的术语体系当中实际上是存在两种不同的抽象，两种抽象，两种抽象的能力和实现。


###  4.2 接口
####  4.2.1 狐狸和兔子的例子
刚才看到的细胞自动机，它是在网格上面有细胞，这个细胞有两种状态，要么是活的，要么是死的。现在想把这个故事向前推进一步，我们想做一个农场。  
##### 狐狸和兔子
* 狐狸和兔子都有年龄
* 当年龄到了一定的上限就会自然死亡
* 狐狸可以随机决定在周围的兔子中吃一个
* 狐狸和兔子可以随机决定生一个小的，放在旁边的空的格子里
* 如果不吃也不生，狐狸和兔子可以随机决定向旁边空的格子移一步

有块地，这块地有狐狸和兔子，它们相互之间有关系，或者它们的互动就比较多。细胞只有死的活的两种状态，当然对于兔子和狐狸来说它们也有死的活的状态，但更复杂的是它们都有年龄。随着程序的进行它们的年龄不断增大，它们的年龄有一个上限，到了上限他就死了。另外呢狐狸和兔子是捕食者和被捕食者的关系，所以狐狸会在它的周围、那一圈，九宫格，8个方格里面有没有兔子，一定几率它会吃一个兔子，吃了兔子之后它的年龄上限就会提高。狐狸和兔子都会生产小狐狸小兔子，有一定几率生一个小的放在旁边，然后那个小的也逐渐张起来。如果不吃也不生，狐狸和兔子也可以移动，走开，在一定几率下。  

我们想实现这么一个复杂的仿真程序，这就比原来的细胞，只有活或死的状态复杂的多。我们看做出来的效果怎么样。  
![abstract3](image/part2/abstract3.png)
这里红色的是兔子，黑色的是狐狸。它们颜色会随着年龄的增长逐渐变淡，越来越淡，淡到最后看不见就死了。在这个过程中狐狸会吃兔子，兔子会来回走动，每次一格，走完若干步后就停下来，形成最终的状态。  

这个程序怎么做呢？当然这个程序我们还是看到和刚才的细胞自动机有相似的元素，都有网格，网格里面都有颜色。但是这里增加了两种东西，这里有狐狸，有兔子，每一种东西随着年龄的增长，颜色会发生变化，变淡，一直到没有为止，会有新的元素加进来。整个程序的架构会是什么样的呢？  

![abstract4](image/part2/abstract4.png)  
我们还是维持了 field 包里有 Field 和 View 这种架构，就是数据和表现是分离的。Field 表达数据，View 表达表现。我们的 Cell 还是那个 Cell。我们用 Fox 和 Rabbit 来分别表达狐狸和兔子。但是在这个类中，Cell 类的定位就很尴尬。  

##### Cell 类的地位很尴尬
* 在 Cells 程序中它表达了细胞

我们在细胞自动机里面，Cell 其实表达的是细胞，细胞有活的有死的，死的细胞是一个白的的框框，活的细胞是一个黑色的框框。Cell 这个单词本意是格子，最开始的意思时候格子，后来用它表达细胞。细胞自动机里面细胞和格子正好是同一种东西。但是到了兔子和狐狸故事当中呢，它的角色就很尴尬。它到底是表达格子呢还是格子里面的东西，因为我们现在的局面是说，在 Field 里面每一个格子其实是三种情况，要么没东西，要么是狐狸，要么是兔子。所以 Cell 到底表达的是什么？也就是说我们的狐狸和兔子这两个类将来做出来后，它们上面的一个父类应该是什么？我们知道从问题本身的角度来说，狐狸和兔子如果有一个共同的父类的话，它们的父类应该是动物，比如 animal，这很合理。因为这这个程序里面，狐狸和兔子有很多相同的动作。比如说每经过一轮它们年龄都要增长，它们都要生小 baby。他们要移动，它们有很多相同的动作。它们相同的动作应该放到相同的父类中去，比如 animal。这是从媒体数据库哪里得到的经验。我们的 CD 和 DVD 有相同的东西应该拿出一个 item 类来，我们 fox 和 robbit 有相同的东西就应该拿出一个 animal 作为他们的父类，可是这时 Cell 怎么办？我们现在的关系如下：  







####  4.2.2 接口


###  4.3 内部类
####  4.3.1 内部类



####  4.3.2 匿名类




####  4.3.3 外部类关系


###  4.4 枚举类
####  4.4.1 枚举类



























endOfPart24
